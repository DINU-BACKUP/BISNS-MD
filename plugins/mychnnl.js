//onst { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')
const { cmd, commands } = require("../lib/command");
//const { cmd } = require("../lib/command");
const yts = require("yt-search");
const axios = require("axios");
const config = require("../settings");


cmd(
  {
    pattern: "dinuwa",
    desc: "Send YouTube MP3 to a specific JID",
    category: "download",
    react: "üéß",
    filename: __filename,
  },
  async (robin, mek, m, { q, reply }) => {
    try {
      if (!q) return reply("*‡∂î‡∂∫‡∑è‡∂Ω‡∑è ‡∂ú‡∑ì‡∂≠ ‡∂±‡∂∏‡∂ö‡∑ä ‡∑Ñ‡∑ù YouTube ‡∂Ω‡∑í‡∂±‡∑ä‡∂ö‡∑ä ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ø‡∑ô‡∂±‡∑ä‡∂±...!*");

      const search = await yts(q);
      if (!search.videos.length) return reply("*‡∂ú‡∑ì‡∂≠‡∂∫ ‡∑Ñ‡∂∏‡∑î‡∂±‡∑ú‡∑Ä‡∑î‡∂´‡∑è... ‚ùå*");

      const data = search.videos[0];
      const ytUrl = data.url;

      const api = `https://yt-five-tau.vercel.app/download?q=${ytUrl}&format=mp3`;
      const { data: apiRes } = await axios.get(api);

      if (!apiRes?.status || !apiRes.result?.download) {
        return reply("‚ùå ‡∂ú‡∑ì‡∂≠‡∂∫ ‡∂∂‡∑è‡∂ú‡∂≠ ‡∂ö‡∑Ö ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö. ‡∑Ä‡∑ô‡∂±‡∂≠‡∑ä ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂ã‡∂≠‡∑ä‡∑É‡∑Ñ ‡∂ö‡∂ª‡∂±‡∑ä‡∂±!");
      }

      const result = apiRes.result;

      const caption = `*~‚ãÜÔΩ°Àö‚òÅÔ∏éÔΩ°‚ãÜÔΩ°__________________________‚ãÜÔΩ°‚òÅÔ∏éÀöÔΩ°‚ãÜ~*

\`‚ùç. Song ‚ûô\` :- *${result.title}*

\`‚ùç.Time ‚ûô\` :-  *${data.timestamp}*          \`‚ùç.Uploaded ‚ûô\` :- *${data.ago}*


> ‚ùù‚ô¨.itz Me Dinuw BbhüòΩüíóüçÉ‚ùû

> üîπ.‚ó¶‚ó¶‚ó¶ \`[üíú||üíõ||ü©∑||ü§ç||üíö]\` 
_*‡∂î‡∂∫‡∑è‡∑Ñ‡∑ö ‡∂Ü‡∑É‡∂∏ ‡∂¥‡∑è‡∂ß‡∑í‡∂∏‡∑ä ‡∂Ω‡∑É‡∑ä‡∑É‡∂± ‡∑Ñ‡∑è‡∂ª‡∑ä‡∂ß‡∑ä ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ø‡∑è‡∂ú‡∑ô‡∂± ‡∂∫‡∂∏‡∑î ‡∑Ö‡∂∏‡∂∫‡∑ù ü´†üíó‚ó¶‚ó¶‚ó¶*_`;

      // Send thumbnail and caption to configured JID
      await robin.sendMessage(
        config.DINUWH,
        {
          image: { url: result.thumbnail },
          caption: caption,
        },
        { quoted: mek }
      );

      // Send audio to the same JID
      await robin.sendMessage(
        config.DINUWH,
        {
          audio: { url: result.download },
          mimetype: "audio/mpeg",
          ptt: true,
        },
        { quoted: mek }
      );

      // Confirmation message to command sender
      await robin.sendMessage(
        mek.key.remoteJid,
        {
          text: `‚úÖ *"${result.title}"* ‡∂±‡∂∏‡∑ä ‡∂ú‡∑ì‡∂≠‡∂∫ *${config.THARUSHA}* ‡∑Ä‡∑ô‡∂≠ ‡∑É‡∑è‡∂ª‡∑ä‡∂Æ‡∂ö‡∑Ä ‡∂∫‡∑Ä‡∂±‡∑î ‡∂Ω‡∑ê‡∂∂‡∑ì‡∂∫.`,
        },
        { quoted: mek }
      );
    } catch (e) {
      console.error(e);
      reply("*‡∂á‡∂≠‡∑ê‡∂∏‡∑ä ‡∂Ø‡∑ù‡∑Ç‡∂∫‡∂ö‡∑í! ‡∂¥‡∑É‡∑î‡∑Ä ‡∂±‡∑ê‡∑Ä‡∂≠ ‡∂ã‡∂≠‡∑ä‡∑É‡∑Ñ ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.*");
    }
  }
);

//=3=3=3=3=3=33=3=3=33=3=3=3==3=3=3=3=3=3=3=3=3==3=3=3=

/* 
Thenux-AI 
   Give credit.*/



//const { cmd } = require('../command');const axios = require('axios');

/*cmd({
    pattern: "tikmanu",
    alias: ["tiktokdl"],
    react: "üé¨",
    desc: "Download TikTok video using the provided URL",
    category: "download",
    filename: __filename
}, async (conn, mek, m, { from, reply, args }) => {
    try {
        // Check if URL is provided
        if (!args[0]) {
            return await reply("üì• Please provide a TikTok video URL.");
        }

        const tiktokUrl = args[0];
        const apiUrl = `https://manul-official-api.vercel.app/scrape-tiktok?url=${encodeURIComponent(tiktokUrl)}&apikey=Manul-Official`;

        // Send request to the API
        const response = await axios.get(apiUrl);

        // Check if the response is successful
        if (response.data.status) {
            const data = response.data.data.data;

            // Prepare the message with video details and options
            const message = `
üé¨ *‰πÇ THENU-MD TIKTOK DOWNLOADER ‚óâ‚óâ‚ñ∫*

‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
1. *Title:* ${data.title}\n
2. *Author:* ${data.author}
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ

*‰πÇ‚óâ‚óâ‚ñ∫ REPLY THE DOWNLOAD OPTION* 

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üì• *Download Options:*

1. *No Watermark Video*

2. *Watermark Video*

3. *Audio*

4. *Thumbnail*

‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Reply with the number of the option you want to download.

> ¬©·¥° ú·¥Ä·¥õÍú±·¥Ä·¥ò·¥ò  ô·¥è·¥õ  ô è Thenu-MD (WOLF-MD)
> *¬©·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è Thenux AI*`;

            // Send the message and save the message ID
            const sentMsg = await conn.sendMessage(from, { image: { url: data.thumbnail }, caption: message }, { quoted: mek });
            const messageID = sentMsg.key.id; // Save the message ID for later reference

            // Listen for the user's response
            conn.ev.on("messages.upsert", async (messageUpdate) => {
                const mek = messageUpdate.messages[0];
                if (!mek.message) return;
                const messageType =
                    mek.message.conversation ||
                    mek.message.extendedTextMessage?.text;
                const from = mek.key.remoteJid;

                // Check if the message is a reply to the previously sent message
                const isReplyToSentMsg =
                    mek.message.extendedTextMessage &&
                    mek.message.extendedTextMessage.contextInfo.stanzaId ===
                        messageID;

                if (isReplyToSentMsg) {
                    // React to the user's reply (the "1", "2", "3", or "4" message)
                    await conn.sendMessage(from, {
                        react: { text: "üåü", key: mek.key },
                    });

                    switch (messageType) {
                        case '1':
                            // Handle option 1 (No Watermark Video)
                            await conn.sendMessage(
                                from,
                                { video: { url: data.nowm }, caption: "Here's your TikTok video without watermark.\n> üëæ THENUX  |   AI „Ç∏" },
                                { quoted: mek }
                            );
                            break;
                        case '2':
                            // Handle option 2 (Watermark Video)
                            await conn.sendMessage(
                                from,
                                { video: { url: data.watermark }, caption: "Here's your TikTok video with watermark.\n> üëæ THENUX  |   AI „Ç∏" },
                                { quoted: mek }
                            );
                            break;
                        case '3':
                            // Handle option 3 (Audio)
                            await conn.sendMessage(
                                from,
                                { audio: { url: data.audio }, mimetype: 'audio/mp4', caption: "Here's the TikTok audio." },
                                { quoted: mek }
                            );
                            break;
                        case '4':
                            // Handle option 4 (Thumbnail)
                            await conn.sendMessage(
                                from,
                                { image: { url: data.thumbnail }, caption: "Here's the TikTok thumbnail.\n> üëæ THENUX  |   AI „Ç∏" },
                                { quoted: mek }
                            );
                            break;
                        default:
                            // Handle invalid input (not 1, 2, 3, or 4)
                            await conn.sendMessage(from, {
                                react: { text: "‚ùì", key: mek.key },
                            });
                            await reply("‚ùå Invalid option. Please reply with a number between 1 and 4.");
                            break;
                    }

                    // React to the successful completion of the task
                    await conn.sendMessage(from, {
                        react: { text : "‚úÖ", key: mek.key },
                    });

                    // Clear the stored TikTok data
                    delete conn.tiktokData;
                }
            });
        } else {
            await reply("‚ùå Unable to fetch TikTok video details. Please check the URL.");
        }
    } catch (error) {
        console.error("Error fetching TikTok video:", error);

        // Enhanced error handling
        if (error.response) {
            await reply(`‚ùå Error: ${error.response.data.message || 'Unable to fetch TikTok video.'}`);
        } else if (error.request) {
            await reply("‚ùå Error: No response received from the TikTok API. Please check your internet connection.");
        } else {
            await reply(`‚ùå Error: ${error.message}`);
        }
    }
});


const fetch = require('node-fetch');

const fetchJson = async (url) => {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`HTTP Error: ${res.status}`);
  return await res.json();
};

cmd({
  pattern: "ta",
  react: "‚¨á",
  filename: __filename
},
async(conn, mek, m, { from, q, reply }) => {
  try {
    if (!q) return reply("üìå ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª TikTok ‡∂Ω‡∑í‡∂±‡∑ä‡∂ö‡∑ä ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ø‡∑ô‡∂±‡∑ä‡∂±!\n‡∂ã‡∂Ø‡∑è: *.ta https://vm.tiktok.com/xxxx*");

    const api = `https://api-mainh-20a12b683c39.herokuapp.com/download/tiktokdl?url=${q}`;
    const res = await fetchJson(api);

    if (!res.result || !res.result.audio) {
      return reply("‚ùå MP3 link ‡∂ë‡∂ö ‡∑Ñ‡∂∏‡∑î‡∑Ä‡∑î‡∂±‡∑ö ‡∂±‡∑ê‡∑Ñ‡∑ê. ‡∂Ω‡∑í‡∂±‡∑ä‡∂ö‡∑ä ‡∂ë‡∂ö ‡∑Ñ‡∂ª‡∑í‡∂Ø ‡∂∂‡∂Ω‡∂±‡∑ä‡∂±!");
    }

    const mp3Link = res.result.audio;

    // React with ‚¨Ü before sending
    await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }});

    // Send as PTT (voice message)
    await conn.sendMessage(from, {
      audio: { url: mp3Link },
      mimetype: 'audio/mpeg',
      ptt: true
    }, { quoted: mek });

    // React with ‚úî after sent
    await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }});

  } catch (e) {
    await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key }});
    console.error(e);
    reply(`üòµ Error!\n\n*${e.message || e}*`);
  }
});*/




cmd(
  {
    pattern: "freedom",
    desc: "Send YouTube MP3 to a specific JID",
    category: "download",
    react: "üéß",
    filename: __filename,
  },
  async (robin, mek, m, { q, reply }) => {
    try {
      if (!q) return reply("*‡∂î‡∂∫‡∑è‡∂Ω‡∑è ‡∂ú‡∑ì‡∂≠ ‡∂±‡∂∏‡∂ö‡∑ä ‡∑Ñ‡∑ù YouTube ‡∂Ω‡∑í‡∂±‡∑ä‡∂ö‡∑ä ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ø‡∑ô‡∂±‡∑ä‡∂±...!*");

      const search = await yts(q);
      if (!search.videos.length) return reply("*‡∂ú‡∑ì‡∂≠‡∂∫ ‡∑Ñ‡∂∏‡∑î‡∂±‡∑ú‡∑Ä‡∑î‡∂´‡∑è... ‚ùå*");

      const data = search.videos[0];
      const ytUrl = data.url;

      const api = `https://yt-five-tau.vercel.app/download?q=${ytUrl}&format=mp3`;
      const { data: apiRes } = await axios.get(api);

      if (!apiRes?.status || !apiRes.result?.download) {
        return reply("‚ùå ‡∂ú‡∑ì‡∂≠‡∂∫ ‡∂∂‡∑è‡∂ú‡∂≠ ‡∂ö‡∑Ö ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö. ‡∑Ä‡∑ô‡∂±‡∂≠‡∑ä ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂ã‡∂≠‡∑ä‡∑É‡∑Ñ ‡∂ö‡∂ª‡∂±‡∑ä‡∂±!");
      }

      const result = apiRes.result;

      const caption = `*~‚ãÜÔΩ°Àö‚òÅÔ∏éÔΩ°‚ãÜÔΩ°__________________________‚ãÜÔΩ°‚òÅÔ∏éÀöÔΩ°‚ãÜ~*

\`‚ùê. Song ‚ûõ\` :- *${result.title}*

\`‚ùê.Time ‚ûõ\` :-  *${data.timestamp}*          \`‚ùê.Uploaded ‚ûõ\` :- *${data.ago}*


> ‚ùù‚ô¨.itz Me Dinuw BbhüòΩüíóüçÉ‚ùû

_*‚úß‡∂Ω‡∑É‡∑ä‡∑É‡∂± ‡∑Ñ‡∑è‡∂ß‡∑ä ‡∂ß‡∑í‡∂ö‡∂ö‡∑ä ‡∂ï‡∂±‡∑ì ‚ù§Ô∏èüòΩ‚òòÔ∏è‚úß*_`;

      // Send thumbnail and caption to configured JID
      await robin.sendMessage(
        config.Freedom,
        {
          image: { url: result.thumbnail },
          caption: caption,
        },
        { quoted: mek }
      );

      // Send audio to the same JID
      await robin.sendMessage(
        config.Freedom,
        {
          audio: { url: result.download },
          mimetype: "audio/mpeg",
          ptt: true,
        },
        { quoted: mek }
      );

      // Confirmation message to command sender
      await robin.sendMessage(
        mek.key.remoteJid,
        {
          text: `‚úÖ *"${result.title}"* ‡∂±‡∂∏‡∑ä ‡∂ú‡∑ì‡∂≠‡∂∫ *${config.Freedom}* ‡∑Ä‡∑ô‡∂≠ ‡∑É‡∑è‡∂ª‡∑ä‡∂Æ‡∂ö‡∑Ä ‡∂∫‡∑Ä‡∂±‡∑î ‡∂Ω‡∑ê‡∂∂‡∑ì‡∂∫.`,
        },
        { quoted: mek }
      );
    } catch (e) {
      console.error(e);
      reply("*‡∂á‡∂≠‡∑ê‡∂∏‡∑ä ‡∂Ø‡∑ù‡∑Ç‡∂∫‡∂ö‡∑í! ‡∂¥‡∑É‡∑î‡∑Ä ‡∂±‡∑ê‡∑Ä‡∂≠ ‡∂ã‡∂≠‡∑ä‡∑É‡∑Ñ ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.*");
    }
  }
);
